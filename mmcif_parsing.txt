之前判断是不是atom级别的alternative：所有原子的构象集合是否等于总构象集合

8ee9：对于atom级别的alternative，即同一残基内某些原子的多构象，这个残基是普通的residue类，有多构象的原子是DisorderedAtom
8fim：同一残基内所有原子都有多构象，也是atom级别的alternative，和上面的一样
8pmf：几乎一整条链的残基内的原子都有多构象。由于残基没有从A变到B，因此仍然只是DisorderedAtom，残基为普通的residue类
8pw0：残基多构象，比如dna链中1位置有A和T两种残基，这时是DisorderedResidue
6u1a：有的位置的残基只有构象B，且占用率不是1.0


residue.is_disordered()只能判断这个残基是否包含多构象原子，不能判断这个残基是否是DisorderedResidue
DisorderedAtom默认选择最大占用的位置
DisorderedResidue默认选择最后添加的残基
再次强调：在biopython中，只要不是残基改变了，都是用DisorderedAtom。因此DisorderedResidue可通过残基名称选择

如果只是残基内部的原子有多构象，就按照默认biopython处理，即每个原子选择占用率最大的构象；即使是残基A的某些原子有构象A或者构象B，残基B的某些原子有构象ABC，也是如此。只要残基本身不是变成另一个残基就行



对于单体（单链）和复合物的parsing，应该分开，即前者使用mmcif文件，后者使用assembly文件
单不论是哪一种，我得到的都是一个字典，包含所有polymer，因此还是要考虑链的多构象

链的多构象（少见）：如果处理不当会有严重错误
e.g. 8eb5
这是一个assembly为两个蛋白+两条dna链的复合物
在cif文件中两条dna链均有A和B两种构象，但与其他的多构象不同（有的虽然是整条链的所有原子均有多构象，但是残基均不变且属于一条链名），
这里的dna链C和C-2是互补的，而D和D-2分别是这两条链的多构象，即多构象用两条链表示。
这导致了cif文件中C链虽然每个原子标识了构象A，但是没有标识构象B，而D链标识了构象B。这种情况下使用biopython也会将所有链解析出来，且只有disorderedatom。这种情况下应该人工处理
判断：如果存在残基，包含多构象且不含A，则应当引发warning



解析序列：
貌似code_can不会有括号，已经把未知的转化为X。我们的程序是最后获取序列，在此之前通过捕获第一个monomer（应对多构象）来获得序列。获得monomer的列表之后，应该先自己使用PDB库的那个字典转化列表得到序列，然后和code_can作比较：1. 长度是否相同 2. 处理code_can的括号后长度是否相同 如果在处理code_can的括号后长度都不相同，说明出了大问题，残基数量都不一致。3. 长度相同后，比较序列是否一致，序列不一致的需要warning出来 4. code_can有括号的应当先转化成X再比较
一般来说，我们期望的是序列长度相同，且不一致的地方是code_can带括号或者转的是X，而我们能转化出来。如果它能转出来而我们不能，其实也能接受。这两种情况都要核对一下。不能接受的是code_can的是标准的，而我们的与其不对应

按照我们的方法，经过验证，我们获得的序列和one_letter_code的每一个氨基酸都是对应的，但是code_can的有些不是单字母，可能是两个字母（这个问题很严重）。所以现在的做法是：就用我们自己的序列，非标准的和未知的都转化为X，即输出的序列只包含20+1或4+1


5una的model有问题，但是assembly没问题